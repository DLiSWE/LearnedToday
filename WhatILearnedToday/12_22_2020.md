<h2>12/22/2021</h2>
Todays objectives:
<ol>
<li>Find CSS designs for: Buttons, Text, Background</li>
<li>Conditioned text format</li>
<li>Complete Base Blog Project</li>
<li>Codewars</li>
</ol>
What I learned (Web/App Development):
<p>When importing CSS from an external site, such as codepen.io, make sure
that you configure the CSS so that you can manipulate the attributes and use those attributes for designing elements that the prebuilt css code wasn't initially created for. In the Udemy Course, we see that we can manipulate a background KEYFRAMES spinify animation and adjust it so text is changed instead of background. Most of the CSS provided have additional code to display the example, so we have to get rid of those elements when we apply it.
</p>
Django Template Formatting:
There is a base.html and all other templates basically inherit specific widgets from the base. The base.html will need the starting 

{% load staticfiles %}

To link to static files in static_root folder. Other templates extend off the base html.

For conditional template designs(if/for/.etc)
Make sure there is an end tag {% if xxx.xxx %}<(somecode)>{% endif %}. For more details. *endif will end if block: Nothing goes after it
https://docs.djangoproject.com/en/dev/ref/templates/language/#variables


*You can use Django with Jinja. Pip install jinja2 and change settings in Django. This link solves this problem.
https://stackoverflow.com/questions/30701631/how-to-use-jinja2-as-a-templating-engine-in-django-1-8*

<h3>Algorithms</h3>
Find domain name for URL:
using replace() method of the static beginnings of the url in the front *critical thinking question*
Recursion Algorithm:
This Works!

```python
def funky(num, list1=[]):
    while num > 0:   
        if num % 2 == 1:
            list1.insert(0,1)
            return funky(num//2)
        elif num % 2 == 0:
            list1.insert(0,0)
            return funky(num//2)
        elif num == 1:
            list1.insert(0,1)
            continue
        elif num == 0:
            list1.insert(0,0)
            continue
        else:
            print('somethings wrong')
print(funky(15))
```

Things to note:
<li>Putting a default list in parameters will allow you to create a list you can iterate results onto when dealing with recursion.</li>

Future Test Cases:
<li> Combining prebuilt CSS snippets </li>

<!-- ===================================================================================================== -->

<h2> 12/23/2021 </h2>
Today's Objectives:
<ol>
<li>Complete Base Blog Project</li>
<li>Data Structure and Algorithms</li>
<li>Codewars</li>
</ol>

<h3>What I learned today:</h3>
The Opposite of Big O is the Omega Notation. Its used to measure the best case scenario.
The Theta Notation is used to measure both best and worst case scenarios
4 Pillars of Software Engineering -> Encapsulation, Abstraction, Inheritance, Polymorphism
This is more less about coding and more about understanding how SWE's think.

Inheritance:
Basis of OOP.
Parents and children.
Ability to 'inherit' another class's methods or functions

Encapsulation:
Wrapping data and methods within class.
Functions and methods within classes defined by private variables (not python, however for developers purposes, we use _varname) defines whether they are within the scope of the function. **name manging**

Polymorphism:
After inheriting, we can modify the function/method taken from the parent and reimplement it for the child class. This is known as **Method Overriding**

Abstraction:
More often seen in javascript
Abstraction can be thought of as a user using a function and getting the result, but all the details of how the function works are "private".
This can also be thought as taking a prebuilt method or object and accessing a specific component in the method/object. We don't necessarily need to know exactly how it's done, but as long as we can implement it, it's OK-ish.
This can be seen with my experience with complex CSS animations. I don't know how to animate text but I can take a code snippet from someone who does and implement it.

Compare current and next value using nested for loop and while loop
```python
#for
def compare(n):
    count = 1
    for i in n:
        for x in n[count:]:
            if i > x:
                count+=1
                return i
#while
def compare1(n):
    count = 0
    count1 = 1
    while count < len(n):
        if n[count] > n[count1]:
            count += 1
            count1 += 1
        if count == len(n)-1:
            break
```

<h3>Linked Lists</h3>




<h3>Django lessons</h3>